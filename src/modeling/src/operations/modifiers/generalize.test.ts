import { expect, test } from "@rbxts/jest-globals";

import { comparePolygonsAsPoints } from "../../../test/helpers";
import { geom3 } from "../../geometries";
import { TAU } from "../../maths/constants";
import { cuboid } from "../../primitives";
import { generalize } from "./index";

test("generalize: generalize of a geom3 produces an expected geom3", () => {
	const geometry1 = cuboid({ size: [TAU / 2, TAU / 4, TAU] });

	// apply no modifications
	let result = generalize({}, geometry1) as Geom3;
	let pts = geom3.toPoints(result);
	let exp: Vec3[][] = [
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
	];
	expect(() => geom3.validate(result)).never.toThrow();
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);

	// apply snap only
	result = generalize({ snap: true }, geometry1) as Geom3;
	pts = geom3.toPoints(result);
	exp = [
		[
			[-1.5707910908071407, -0.7854138713607164, -3.1415821816142815],
			[-1.5707910908071407, -0.7854138713607164, 3.1415821816142815],
			[-1.5707910908071407, 0.7854138713607164, 3.1415821816142815],
			[-1.5707910908071407, 0.7854138713607164, -3.1415821816142815],
		],
		[
			[1.5707910908071407, -0.7854138713607164, -3.1415821816142815],
			[1.5707910908071407, 0.7854138713607164, -3.1415821816142815],
			[1.5707910908071407, 0.7854138713607164, 3.1415821816142815],
			[1.5707910908071407, -0.7854138713607164, 3.1415821816142815],
		],
		[
			[-1.5707910908071407, -0.7854138713607164, -3.1415821816142815],
			[1.5707910908071407, -0.7854138713607164, -3.1415821816142815],
			[1.5707910908071407, -0.7854138713607164, 3.1415821816142815],
			[-1.5707910908071407, -0.7854138713607164, 3.1415821816142815],
		],
		[
			[-1.5707910908071407, 0.7854138713607164, -3.1415821816142815],
			[-1.5707910908071407, 0.7854138713607164, 3.1415821816142815],
			[1.5707910908071407, 0.7854138713607164, 3.1415821816142815],
			[1.5707910908071407, 0.7854138713607164, -3.1415821816142815],
		],
		[
			[-1.5707910908071407, -0.7854138713607164, -3.1415821816142815],
			[-1.5707910908071407, 0.7854138713607164, -3.1415821816142815],
			[1.5707910908071407, 0.7854138713607164, -3.1415821816142815],
			[1.5707910908071407, -0.7854138713607164, -3.1415821816142815],
		],
		[
			[-1.5707910908071407, -0.7854138713607164, 3.1415821816142815],
			[1.5707910908071407, -0.7854138713607164, 3.1415821816142815],
			[1.5707910908071407, 0.7854138713607164, 3.1415821816142815],
			[-1.5707910908071407, 0.7854138713607164, 3.1415821816142815],
		],
	];
	expect(() => geom3.validate(result)).never.toThrow();
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);

	// apply triangulate only
	result = generalize({ triangulate: true }, geometry1) as Geom3;
	pts = geom3.toPoints(result);
	exp = [
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
		[
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
	];
	expect(() => geom3.validate(result)).never.toThrow();
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);

	const geometry2 = result; // save the triangles for another test

	// apply simplify only (triangles => quads)
	result = generalize({ simplify: true }, geometry2) as Geom3;
	pts = geom3.toPoints(result);
	exp = [
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
		],
		[
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, -3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, -3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, -3.141592653589793],
		],
		[
			[-1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, -0.7853981633974483, 3.141592653589793],
			[1.5707963267948966, 0.7853981633974483, 3.141592653589793],
			[-1.5707963267948966, 0.7853981633974483, 3.141592653589793],
		],
	];
	expect(() => geom3.validate(result)).never.toThrow();
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);
});

test("generalize: generalize of a geom3 with T junctions produces an expected geom3", () => {
	const geometry1 = geom3.fromPoints([
		[
			[-1, -1, -1],
			[-1, -1, 1],
			[-1, 1, 1],
			[-1, 1, -1],
		],
		[
			[1, -1, -1],
			[1, 1, -1],
			[1, 1, 1],
			[1, -1, 1],
		],
		[
			[-1, -1, -1],
			[1, -1, -1],
			[1, -1, 1],
			[-1, -1, 1],
		],
		[
			[-1, 1, -1],
			[-1, 1, 1],
			[1, 1, 1],
			[1, 1, -1],
		],
		[
			[-1, -1, -1],
			[-1, 1, -1],
			[1, 1, -1],
			[1, -1, -1],
		],
		// T junctions
		[
			[-1, -1, 1],
			[0, -1, 1],
			[0, 0, 1],
		],
		[
			[-1, 0, 1],
			[-1, -1, 1],
			[0, 0, 1],
		],

		[
			[0, -1, 1],
			[1, -1, 1],
			[0, 0, 1],
		],
		[
			[1, -1, 1],
			[1, 0, 1],
			[0, 0, 1],
		],

		[
			[1, 0, 1],
			[1, 1, 1],
			[0, 0, 1],
		],
		[
			[1, 1, 1],
			[0, 1, 1],
			[0, 0, 1],
		],

		[
			[0, 1, 1],
			[-1, 1, 1],
			[0, 0, 1],
		],
		[
			[-1, 1, 1],
			[-1, 0, 1],
			[0, 0, 1],
		],
	]);

	const result = generalize({ snap: true, triangulate: true }, geometry1) as Geom3;
	const pts = geom3.toPoints(result);
	const exp: Vec3[][] = [
		[
			[-1, 0, 0.2],
			[-1, -1, -1],
			[-1, -1, 1],
		],
		[
			[-1, 0, 0.2],
			[-1, -1, 1],
			[-1, 0, 1],
		],
		[
			[-1, 0, 0.2],
			[-1, 0, 1],
			[-1, 1, 1],
		],
		[
			[-1, 0, 0.2],
			[-1, 1, 1],
			[-1, 1, -1],
		],
		[
			[-1, 0, 0.2],
			[-1, 1, -1],
			[-1, -1, -1],
		],
		[
			[1, 0, 0.2],
			[1, -1, -1],
			[1, 1, -1],
		],
		[
			[1, 0, 0.2],
			[1, 1, -1],
			[1, 1, 1],
		],
		[
			[1, 0, 0.2],
			[1, 1, 1],
			[1, 0, 1],
		],
		[
			[1, 0, 0.2],
			[1, 0, 1],
			[1, -1, 1],
		],
		[
			[1, 0, 0.2],
			[1, -1, 1],
			[1, -1, -1],
		],
		[
			[0, -1, 0.2],
			[-1, -1, -1],
			[1, -1, -1],
		],
		[
			[0, -1, 0.2],
			[1, -1, -1],
			[1, -1, 1],
		],
		[
			[0, -1, 0.2],
			[1, -1, 1],
			[0, -1, 1],
		],
		[
			[0, -1, 0.2],
			[0, -1, 1],
			[-1, -1, 1],
		],
		[
			[0, -1, 0.2],
			[-1, -1, 1],
			[-1, -1, -1],
		],
		[
			[0, 1, 0.2],
			[-1, 1, -1],
			[-1, 1, 1],
		],
		[
			[0, 1, 0.2],
			[-1, 1, 1],
			[0, 1, 1],
		],
		[
			[0, 1, 0.2],
			[0, 1, 1],
			[1, 1, 1],
		],
		[
			[0, 1, 0.2],
			[1, 1, 1],
			[1, 1, -1],
		],
		[
			[0, 1, 0.2],
			[1, 1, -1],
			[-1, 1, -1],
		],
		[
			[-1, -1, -1],
			[-1, 1, -1],
			[1, 1, -1],
		],
		[
			[-1, -1, -1],
			[1, 1, -1],
			[1, -1, -1],
		],
		[
			[-1, -1, 1],
			[0, -1, 1],
			[0, 0, 1],
		],
		[
			[-1, 0, 1],
			[-1, -1, 1],
			[0, 0, 1],
		],
		[
			[0, -1, 1],
			[1, -1, 1],
			[0, 0, 1],
		],
		[
			[1, -1, 1],
			[1, 0, 1],
			[0, 0, 1],
		],
		[
			[1, 0, 1],
			[1, 1, 1],
			[0, 0, 1],
		],
		[
			[1, 1, 1],
			[0, 1, 1],
			[0, 0, 1],
		],
		[
			[0, 1, 1],
			[-1, 1, 1],
			[0, 0, 1],
		],
		[
			[-1, 1, 1],
			[-1, 0, 1],
			[0, 0, 1],
		],
	];
	expect(() => geom3.validate(result)).never.toThrow();
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);
});
