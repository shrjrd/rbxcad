import { expect, test } from "@rbxts/jest-globals";

import comparePolygonsAsPoints from "../../../test/helpers/comparePolygonsAsPoints";
import { geom2, geom3, path2 } from "../../geometries";
import { TAU } from "../../maths/constants";
import { extrudeLinear } from "./index";

test("extrudeLinear (defaults)", () => {
	const geometry2 = geom2.fromPoints([
		[5, 5],
		[-5, 5],
		[-5, -5],
		[5, -5],
	]);

	const geometry3 = extrudeLinear({}, geometry2) as Geom3;
	const pts = geom3.toPoints(geometry3);
	const exp: Vec3[][] = [
		[
			[5, -5, 0],
			[5, 5, 0],
			[5, 5, 1],
		],
		[
			[5, -5, 0],
			[5, 5, 1],
			[5, -5, 1],
		],
		[
			[5, 5, 0],
			[-5, 5, 0],
			[-5, 5, 1],
		],
		[
			[5, 5, 0],
			[-5, 5, 1],
			[5, 5, 1],
		],
		[
			[-5, 5, 0],
			[-5, -5, 0],
			[-5, -5, 1],
		],
		[
			[-5, 5, 0],
			[-5, -5, 1],
			[-5, 5, 1],
		],
		[
			[-5, -5, 0],
			[5, -5, 0],
			[5, -5, 1],
		],
		[
			[-5, -5, 0],
			[5, -5, 1],
			[-5, -5, 1],
		],
		[
			[-5, -5, 1],
			[5, -5, 1],
			[5, 5, 1],
		],
		[
			[5, 5, 1],
			[-5, 5, 1],
			[-5, -5, 1],
		],
		[
			[5, 5, 0],
			[5, -5, 0],
			[-5, -5, 0],
		],
		[
			[-5, -5, 0],
			[-5, 5, 0],
			[5, 5, 0],
		],
	];
	expect(() => geom3.validate(geometry3)).never.toThrow();
	expect(pts.size()).toBe(12);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);
});

test("extrudeLinear (no twist)", () => {
	const geometry2 = geom2.fromPoints([
		[5, 5],
		[-5, 5],
		[-5, -5],
		[5, -5],
	]);

	let geometry3 = extrudeLinear({ height: 15 }, geometry2) as Geom3;
	let pts = geom3.toPoints(geometry3);
	let exp: Vec3[][] = [
		[
			[5, -5, 0],
			[5, 5, 0],
			[5, 5, 15],
		],
		[
			[5, -5, 0],
			[5, 5, 15],
			[5, -5, 15],
		],
		[
			[5, 5, 0],
			[-5, 5, 0],
			[-5, 5, 15],
		],
		[
			[5, 5, 0],
			[-5, 5, 15],
			[5, 5, 15],
		],
		[
			[-5, 5, 0],
			[-5, -5, 0],
			[-5, -5, 15],
		],
		[
			[-5, 5, 0],
			[-5, -5, 15],
			[-5, 5, 15],
		],
		[
			[-5, -5, 0],
			[5, -5, 0],
			[5, -5, 15],
		],
		[
			[-5, -5, 0],
			[5, -5, 15],
			[-5, -5, 15],
		],
		[
			[-5, -5, 15],
			[5, -5, 15],
			[5, 5, 15],
		],
		[
			[5, 5, 15],
			[-5, 5, 15],
			[-5, -5, 15],
		],
		[
			[5, 5, 0],
			[5, -5, 0],
			[-5, -5, 0],
		],
		[
			[-5, -5, 0],
			[-5, 5, 0],
			[5, 5, 0],
		],
	];
	expect(() => geom3.validate(geometry3)).never.toThrow();
	expect(pts.size()).toBe(12);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);

	geometry3 = extrudeLinear({ height: -15 }, geometry2) as Geom3;
	pts = geom3.toPoints(geometry3);
	exp = [
		[
			[5, 5, 0],
			[5, -5, 0],
			[5, -5, -15],
		],
		[
			[5, 5, 0],
			[5, -5, -15],
			[5, 5, -15],
		],
		[
			[-5, 5, 0],
			[5, 5, 0],
			[5, 5, -15],
		],
		[
			[-5, 5, 0],
			[5, 5, -15],
			[-5, 5, -15],
		],
		[
			[-5, -5, 0],
			[-5, 5, 0],
			[-5, 5, -15],
		],
		[
			[-5, -5, 0],
			[-5, 5, -15],
			[-5, -5, -15],
		],
		[
			[5, -5, 0],
			[-5, -5, 0],
			[-5, -5, -15],
		],
		[
			[5, -5, 0],
			[-5, -5, -15],
			[5, -5, -15],
		],
		[
			[-5, 5, -15],
			[5, 5, -15],
			[5, -5, -15],
		],
		[
			[5, -5, -15],
			[-5, -5, -15],
			[-5, 5, -15],
		],
		[
			[5, -5, 0],
			[5, 5, 0],
			[-5, 5, 0],
		],
		[
			[-5, 5, 0],
			[-5, -5, 0],
			[5, -5, 0],
		],
	];
	expect(() => geom3.validate(geometry3)).never.toThrow();
	expect(pts.size()).toBe(12);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);
});

test("extrudeLinear (twist)", () => {
	const geometry2 = geom2.fromPoints([
		[5, 5],
		[-5, 5],
		[-5, -5],
		[5, -5],
	]);

	let geometry3 = extrudeLinear({ height: 15, twistAngle: -TAU / 8 }, geometry2) as Geom3;
	let pts = geom3.toPoints(geometry3);
	let exp: Vec3[][] = [
		[
			[5, -5, 0],
			[5, 5, 0],
			[7.0710678118654755, 4.440892098500626e-16, 15],
		],
		[
			[5, -5, 0],
			[7.0710678118654755, 4.440892098500626e-16, 15],
			[4.440892098500626e-16, -7.0710678118654755, 15],
		],
		[
			[5, 5, 0],
			[-5, 5, 0],
			[-4.440892098500626e-16, 7.0710678118654755, 15],
		],
		[
			[5, 5, 0],
			[-4.440892098500626e-16, 7.0710678118654755, 15],
			[7.0710678118654755, 4.440892098500626e-16, 15],
		],
		[
			[-5, 5, 0],
			[-5, -5, 0],
			[-7.0710678118654755, -4.440892098500626e-16, 15],
		],
		[
			[-5, 5, 0],
			[-7.0710678118654755, -4.440892098500626e-16, 15],
			[-4.440892098500626e-16, 7.0710678118654755, 15],
		],
		[
			[-5, -5, 0],
			[5, -5, 0],
			[4.440892098500626e-16, -7.0710678118654755, 15],
		],
		[
			[-5, -5, 0],
			[4.440892098500626e-16, -7.0710678118654755, 15],
			[-7.0710678118654755, -4.440892098500626e-16, 15],
		],
		[
			[-7.0710678118654755, -4.440892098500626e-16, 15],
			[4.440892098500626e-16, -7.0710678118654755, 15],
			[7.0710678118654755, 4.440892098500626e-16, 15],
		],
		[
			[7.0710678118654755, 4.440892098500626e-16, 15],
			[-4.440892098500626e-16, 7.0710678118654755, 15],
			[-7.0710678118654755, -4.440892098500626e-16, 15],
		],
		[
			[5, 5, 0],
			[5, -5, 0],
			[-5, -5, 0],
		],
		[
			[-5, -5, 0],
			[-5, 5, 0],
			[5, 5, 0],
		],
	];
	expect(() => geom3.validate(geometry3)).never.toThrow();
	expect(pts.size()).toBe(12);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);

	geometry3 = extrudeLinear({ height: 15, twistAngle: TAU / 4, twistSteps: 3 }, geometry2) as Geom3;
	pts = geom3.toPoints(geometry3);
	exp = [
		[
			[5, -5, 0],
			[5, 5, 0],
			[1.830127018922194, 6.830127018922193, 5],
		],
		[
			[5, -5, 0],
			[1.830127018922194, 6.830127018922193, 5],
			[6.830127018922193, -1.830127018922194, 5],
		],
		[
			[5, 5, 0],
			[-5, 5, 0],
			[-6.830127018922193, 1.830127018922194, 5],
		],
		[
			[5, 5, 0],
			[-6.830127018922193, 1.830127018922194, 5],
			[1.830127018922194, 6.830127018922193, 5],
		],
		[
			[-5, 5, 0],
			[-5, -5, 0],
			[-1.830127018922194, -6.830127018922193, 5],
		],
		[
			[-5, 5, 0],
			[-1.830127018922194, -6.830127018922193, 5],
			[-6.830127018922193, 1.830127018922194, 5],
		],
		[
			[-5, -5, 0],
			[5, -5, 0],
			[6.830127018922193, -1.830127018922194, 5],
		],
		[
			[-5, -5, 0],
			[6.830127018922193, -1.830127018922194, 5],
			[-1.830127018922194, -6.830127018922193, 5],
		],
		[
			[6.830127018922193, -1.830127018922194, 5],
			[1.830127018922194, 6.830127018922193, 5],
			[-1.8301270189221923, 6.830127018922193, 10],
		],
		[
			[6.830127018922193, -1.830127018922194, 5],
			[-1.8301270189221923, 6.830127018922193, 10],
			[6.830127018922193, 1.8301270189221923, 10],
		],
		[
			[1.830127018922194, 6.830127018922193, 5],
			[-6.830127018922193, 1.830127018922194, 5],
			[-6.830127018922193, -1.8301270189221923, 10],
		],
		[
			[1.830127018922194, 6.830127018922193, 5],
			[-6.830127018922193, -1.8301270189221923, 10],
			[-1.8301270189221923, 6.830127018922193, 10],
		],
		[
			[-6.830127018922193, 1.830127018922194, 5],
			[-1.830127018922194, -6.830127018922193, 5],
			[1.8301270189221923, -6.830127018922193, 10],
		],
		[
			[-6.830127018922193, 1.830127018922194, 5],
			[1.8301270189221923, -6.830127018922193, 10],
			[-6.830127018922193, -1.8301270189221923, 10],
		],
		[
			[-1.830127018922194, -6.830127018922193, 5],
			[6.830127018922193, -1.830127018922194, 5],
			[6.830127018922193, 1.8301270189221923, 10],
		],
		[
			[-1.830127018922194, -6.830127018922193, 5],
			[6.830127018922193, 1.8301270189221923, 10],
			[1.8301270189221923, -6.830127018922193, 10],
		],
		[
			[6.830127018922193, 1.8301270189221923, 10],
			[-1.8301270189221923, 6.830127018922193, 10],
			[-5, 5, 15],
		],
		[
			[6.830127018922193, 1.8301270189221923, 10],
			[-5, 5, 15],
			[5, 5, 15],
		],
		[
			[-1.8301270189221923, 6.830127018922193, 10],
			[-6.830127018922193, -1.8301270189221923, 10],
			[-5, -5, 15],
		],
		[
			[-1.8301270189221923, 6.830127018922193, 10],
			[-5, -5, 15],
			[-5, 5, 15],
		],
		[
			[-6.830127018922193, -1.8301270189221923, 10],
			[1.8301270189221923, -6.830127018922193, 10],
			[5, -5, 15],
		],
		[
			[-6.830127018922193, -1.8301270189221923, 10],
			[5, -5, 15],
			[-5, -5, 15],
		],
		[
			[1.8301270189221923, -6.830127018922193, 10],
			[6.830127018922193, 1.8301270189221923, 10],
			[5, 5, 15],
		],
		[
			[1.8301270189221923, -6.830127018922193, 10],
			[5, 5, 15],
			[5, -5, 15],
		],
		[
			[5, -5, 15],
			[5, 5, 15],
			[-5, 5, 15],
		],
		[
			[-5, 5, 15],
			[-5, -5, 15],
			[5, -5, 15],
		],
		[
			[5, 5, 0],
			[5, -5, 0],
			[-5, -5, 0],
		],
		[
			[-5, -5, 0],
			[-5, 5, 0],
			[5, 5, 0],
		],
	];
	expect(pts.size()).toBe(28);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);

	geometry3 = extrudeLinear({ height: 15, twistAngle: TAU / 2, twistSteps: 30 }, geometry2) as Geom3;
	pts = geom3.toPoints(geometry3);
	expect(() => geom3.validate(geometry3)).never.toThrow();
	expect(pts.size()).toBe(244);
});

test("extrudeLinear (holes)", () => {
	const geometry2 = geom2.create([
		[
			[-5, 5],
			[-5, -5],
		],
		[
			[-5, -5],
			[5, -5],
		],
		[
			[5, -5],
			[5, 5],
		],
		[
			[5, 5],
			[-5, 5],
		],
		[
			[-2, -2],
			[-2, 2],
		],
		[
			[2, -2],
			[-2, -2],
		],
		[
			[2, 2],
			[2, -2],
		],
		[
			[-2, 2],
			[2, 2],
		],
	]);
	const geometry3 = extrudeLinear({ height: 15 }, geometry2) as Geom3;
	const pts = geom3.toPoints(geometry3);
	const exp: Vec3[][] = [
		[
			[-5, 5, 0],
			[-5, -5, 0],
			[-5, -5, 15],
		],
		[
			[-5, 5, 0],
			[-5, -5, 15],
			[-5, 5, 15],
		],
		[
			[-5, -5, 0],
			[5, -5, 0],
			[5, -5, 15],
		],
		[
			[-5, -5, 0],
			[5, -5, 15],
			[-5, -5, 15],
		],
		[
			[5, -5, 0],
			[5, 5, 0],
			[5, 5, 15],
		],
		[
			[5, -5, 0],
			[5, 5, 15],
			[5, -5, 15],
		],
		[
			[5, 5, 0],
			[-5, 5, 0],
			[-5, 5, 15],
		],
		[
			[5, 5, 0],
			[-5, 5, 15],
			[5, 5, 15],
		],
		[
			[-2, -2, 0],
			[-2, 2, 0],
			[-2, 2, 15],
		],
		[
			[-2, -2, 0],
			[-2, 2, 15],
			[-2, -2, 15],
		],
		[
			[2, -2, 0],
			[-2, -2, 0],
			[-2, -2, 15],
		],
		[
			[2, -2, 0],
			[-2, -2, 15],
			[2, -2, 15],
		],
		[
			[2, 2, 0],
			[2, -2, 0],
			[2, -2, 15],
		],
		[
			[2, 2, 0],
			[2, -2, 15],
			[2, 2, 15],
		],
		[
			[-2, 2, 0],
			[2, 2, 0],
			[2, 2, 15],
		],
		[
			[-2, 2, 0],
			[2, 2, 15],
			[-2, 2, 15],
		],
		[
			[5, -5, 15],
			[5, 5, 15],
			[2, 2, 15],
		],
		[
			[-2, 2, 15],
			[2, 2, 15],
			[5, 5, 15],
		],
		[
			[5, -5, 15],
			[2, 2, 15],
			[2, -2, 15],
		],
		[
			[-2, 2, 15],
			[5, 5, 15],
			[-5, 5, 15],
		],
		[
			[-5, -5, 15],
			[5, -5, 15],
			[2, -2, 15],
		],
		[
			[-2, -2, 15],
			[-2, 2, 15],
			[-5, 5, 15],
		],
		[
			[-5, -5, 15],
			[2, -2, 15],
			[-2, -2, 15],
		],
		[
			[-2, -2, 15],
			[-5, 5, 15],
			[-5, -5, 15],
		],
		[
			[2, 2, 0],
			[5, 5, 0],
			[5, -5, 0],
		],
		[
			[5, 5, 0],
			[2, 2, 0],
			[-2, 2, 0],
		],
		[
			[2, -2, 0],
			[2, 2, 0],
			[5, -5, 0],
		],
		[
			[-5, 5, 0],
			[5, 5, 0],
			[-2, 2, 0],
		],
		[
			[2, -2, 0],
			[5, -5, 0],
			[-5, -5, 0],
		],
		[
			[-5, 5, 0],
			[-2, 2, 0],
			[-2, -2, 0],
		],
		[
			[-2, -2, 0],
			[2, -2, 0],
			[-5, -5, 0],
		],
		[
			[-5, -5, 0],
			[-5, 5, 0],
			[-2, -2, 0],
		],
	];
	expect(() => geom3.validate(geometry3)).never.toThrow();
	expect(pts.size()).toBe(32);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);
});

test("extrudeLinear (path2)", () => {
	const geometry2 = path2.fromPoints({ closed: true }, [
		[0, 0],
		[12, 0],
		[6, 10],
	]);
	const geometry3 = extrudeLinear({ height: 15 }, geometry2) as Geom3;
	expect(() => geom3.validate(geometry3)).never.toThrow();
	const pts = geom3.toPoints(geometry3);
	const exp: Vec3[][] = [
		[
			[6, 10, 0],
			[0, 0, 0],
			[0, 0, 15],
		],
		[
			[6, 10, 0],
			[0, 0, 15],
			[6, 10, 15],
		],
		[
			[0, 0, 0],
			[12, 0, 0],
			[12, 0, 15],
		],
		[
			[0, 0, 0],
			[12, 0, 15],
			[0, 0, 15],
		],
		[
			[12, 0, 0],
			[6, 10, 0],
			[6, 10, 15],
		],
		[
			[12, 0, 0],
			[6, 10, 15],
			[12, 0, 15],
		],
		[
			[12, 0, 15],
			[6, 10, 15],
			[0, 0, 15],
		],
		[
			[0, 0, 0],
			[6, 10, 0],
			[12, 0, 0],
		],
	];

	expect(pts.size()).toBe(8);
	expect(comparePolygonsAsPoints(pts, exp)).toBe(true);
});

test("extrudeLinear (unclosed path throws error)", () => {
	const geometry2 = path2.fromPoints({ closed: false }, [
		[0, 0],
		[12, 0],
		[6, 10],
	]);
	expect(() => extrudeLinear({}, geometry2)).toThrow();
});
